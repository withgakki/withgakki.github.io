---
layout:     post                    # 使用的布局（不需要改）
title:      正则表达式笔记          # 标题 
subtitle:   用的多才能记住！       #副标题
date:       2019-05-26              # 时间
author:     KW                      # 作者
header-img: img/燃情岁月.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 正则
---

刷题的时候发现了关于正则表达式的题，完全忘干净了  
好好总结一下

### 正则基础知识点

#### 元字符

元字符是构造正则表达式的一种基本元素

|        元字符 |说明                           |
|:-------------:|:-----------------------------|
|   `.`     |     匹配除换行符以外的任意字符     |
|  `\w`   |    匹配字母或数字或下划线或汉字   |
|   `\s`   |    匹配任意的空白符          |
|   `\d`   |    匹配数字 |
|  `\b`    |    匹配单词的开始或结束   |
|  `^`     |    匹配字符串的开始       |
|   `$`    |    匹配字符串的结束       |

利用元字符来写一些简单的正则表达式了，比如：

1. 匹配有 abc 开头的字符串：  
`\babc 或者 ^abc`
2. 匹配8位数字的QQ号码：  
`^\d\d\d\d\d\d\d\d$`
3. 匹配1开头11位数字的手机号码：  
`^1\d\d\d\d\d\d\d\d\d\d$`

#### 重复限定符

上面几个式子可以发现重复的比较多，并不简明扼要，这个时候就需要重复限定符了

重复限定符，把重复部分用合适的限定符替代

|   语法       |说明                           |
|:-------------:|:-----------------------------|
|   `*`     |     重复零次或更多次     |
|  `+`     |    重复一次或更多次  |
|   `?`    |    重复零次或一次                 |
|   `{n}`   |    重复n次                      |
|  `{n,}`    |   重复n次或更多次              |
|  `{n,m}`  |    重复n到m次                    |

有了这些限定符之后，我们就可以对之前的正则表达式进行改造了

1. 匹配8位数字的QQ号码：  
`^\d{8}$`
2. 匹配1开头11位数字的手机号码：  
`^1\d{10}$`
3. 匹配以a开头的，0个或多个b结尾的字符串：  
`^ab*$`

#### 分组与区间

> 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。

如：匹配字符串中包含0到多个ab开头： `^(ab)*`

> 正则提供一个元字符中括号 [] 来表示区间条件。
> 1. 限定 0 到 9 可以写成 [0-9]
> 2. 限定 A-Z 写成 [A-Z]
> 3. 限定某些数字 [418]

如：联通有130/131/132/155/156/185/186/145/176等号段：  
`^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$`

#### 条件或与转义

> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。  
> 有时候我们要把元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是 `\` 即可。

### Java使用正则

#### 1. 匹配

String  matches() 方法。用规则匹配整个字符串，只要有一处不符合规则，就匹配结束，返回false。

```java
public static void checkQQ(){
        String qq = "123a45664";
        String regex = "[1-9]\\d{4,14}";
        boolean flag = qq.matches(regex);
        if(flag)
            System.out.println(qq+"...is ok");
        else
            System.out.println(qq+"... 不合法");
}             //不合法
```

#### 2. 切割

String split() 方法;  
根据给定正则表达式的匹配拆分此字符串。返回一个数组。

```java
public static void splitDemo() {
        String str = "erkktyqqquizzzzzo";
        String reg ="(.)\\1+";//按照叠词来进行切割
            //可以将规则封装成一个组。用()完成。组的出现都有编号。
            //从1开始。 想要使用已有的组可以通过  \n(n就是组的编号)的形式来获取。
        String[] arr = str.split(reg);  
        System.out.println(arr.length);
        for(String s : arr) {
            System.out.println(s);
        }
    }  
    // er，ty，ui，o
```

#### 3. 替换

String replaceAll(regex,str) 方法;  
使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。  
ps：如果regex中有定义组，可以在第二参数中通过$符号获取正则表达式中的已有的组。

```java
 public static void replaceAllDemo() {
        String str = "wer1389980000ty1234564uiod234345675f";//将字符串中的数字替换成#。
        str = str.replaceAll("\\d{5,}","#");
        System.out.println(str);
    }
    // wer#ty#uio#f
```

```java
 public static void replaceAllDemo() {
        String str1 = "erkktyqqquizzzzzo";//将叠词替换成$.  //将重叠的字符替换成单个字母。zzzz->z
        str = str.replaceAll("(.)\\1+","$1");
        System.out.println(str);
    }
    // erktyquizo
```

#### 4. 获取

将字符串中的符合规则的子串取出。操作步骤：

1. 将正则表达式封装成对象。
2. 让正则对象和要操作的字符串相关联。
3. 关联后，获取正则匹配引擎。
4. 通过引擎对符合规则的子串进行操作，比如取出。

```java
public static void getDemo() {
        String str = "yin yu shi wo zui cai de yu yan";
        System.out.println(str);
        String reg = "\\b[a-z]{3}\\b";//匹配只有三个字母的单词
        Pattern p = Pattern.compile(reg);   //将规则封装成对象。
        //让正则对象和要作用的字符串相关联。获取匹配器对象。
        Matcher m  = p.matcher(str);
        // System.out.println(m.matches());//其实String类中的matches方法。用的就是Pattern和Matcher对象来完成的。
        //只不过被String的方法封装后，用起来较为简单。但是功能却单一。
        // boolean b = m.find();//将规则作用到字符串上，并进行符合规则的子串查找。
        // System.out.println(b);
        // System.out.println(m.group());//用于获取匹配后结果。
        while(m.find()) {
            System.out.println(m.group());
            System.out.println(m.start()+"...."+m.end());  // start()  字符的开始下标（包含） //end()  字符的结束下标（不包含）
        }
    }
```

1. 如果只想知道该字符是否对是错，使用匹配。
2. 想要将已有的字符串变成另一个字符串，替换。
3. 想要按照自定的方式将字符串变成多个字符串。切割。获取规则以外的子串。
4. 想要拿到符合需求的字符串子串，获取。获取符合规则的子串。

### 进阶知识点

#### 零宽断言

> 1. 断言：俗话的断言就是“断定什么为什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容。
> 2. 零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。

假设我们要用爬虫抓取某篇文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构：

```html
"<span class="read-count">阅读数：641</span>"
```

当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？

下面先来讲几种类型的断言：

> 正向先行断言（正前瞻）：
> + 语法：（?=pattern）
> + 作用：匹配pattern表达式的前面内容，不返回本身。

即用`"\\d+(?=</span>)"`去匹配，得到：641
这正是我们想要的结果

> 正向后行断言（正后顾）:
> + 语法：（?<=pattern）
> + 作用：匹配pattern表达式的后面的内容，不返回本身。

可以使用`"(?<=<span class=\"read-count\">阅读数：)\\d+"`匹配，得到：641

> 负向先行断言（负前瞻）:
> + 语法：(?!pattern)
> + 作用：匹配非pattern表达式的前面内容，不返回本身。

有正向也有负向，负向在这里其实就是非的意思。

> 负向后行断言（负后顾）:
> + 语法：(?<!pattern)
> + 作用：匹配非pattern表达式的后面内容，不返回本身。

#### 捕获和非捕获

单纯说到捕获，意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”

> 捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。

而根据命名方式的不同，又可以分为两种组：

> 1. 数字编号捕获组：
语法：(exp)
解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。

```java
public static void main(String args[]) {
        String test = "020-85653333";
        String reg="(0\\d{2})-(\\d{8})";
        Pattern pattern = Pattern.compile(reg);
        Matcher mc= pattern.matcher(test);
        if(mc.find()){
            System.out.println("分组的个数有："+mc.groupCount());
            for(int i=0;i<=mc.groupCount();i++){
                System.out.println("第"+i+"个分组为："+mc.group(i));
        }
    }
}
```

输出结果：

```cmd
分组的个数有：2
第0个分组为：020-85653333
第1个分组为：020
第2个分组为：85653333
```

> 2. 命名编号捕获组：
语法：(?<name>exp)
解释：分组的命名由表达式中的 name 指定

```java
public static void main(String args[]){
        String test = "020-85653333";
        String reg="(?<quhao>0\\d{2})-(?<haoma>\\d{8})";
        Pattern pattern = Pattern.compile(reg);
        Matcher mc= pattern.matcher(test);
        if(mc.find()){
             System.out.println("分组的个数有："+mc.groupCount());
             System.out.println(mc.group("quhao"));
             System.out.println(mc.group("haoma"));
        }
    }
```

输出结果：

```cmd
分组的个数有：2
020
85653333
```

> 非捕获组( ?:Pattern )

 它的作用就是匹配 Pattern 字符，好处就是不捕获文本，不将匹配到的字符存储到内存中，从而节省内存。

【例】匹配 indestry 或者 indestries
我们可以使用 indestr(y|ies) 或者 indestr(?:y|ies)

【例】(?:a\|A)123(?:b) 可以匹配 a123b 或者 A123b

#### 反向引用

上面讲到捕获，我们知道：**捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。**

> 根据捕获组的命名规则，反向引用可分为：
> 数字编号组反向引用：\k 或者 \number
> 命名编号组反向引用：\k 或者 \'name'

如：匹配 "This is a 'string'" 里面的单引号内容，采用反向引用：`(\"|').*?\1`

#### 贪婪和非贪婪

##### 贪婪

> 贪婪匹配：当正则表达式中包含能接受重复的限定符时，默认的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。  
特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。

前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：`\d{3,6}`  
用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。

> 如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？

是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。

##### 懒惰（非贪婪）

> 懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。

|   语法       |说明                           |
|:-------------:|:-----------------------------|
|   `*?`     |     重复任意次，但尽可能少重复     |
|  `+?`     |    重复1次或更多次，但尽可能少重复  |
|   `??`   |    重复0次或1次，但尽可能少重复         |
|  `{n,m}?`    |   重复 n 到 m 次，但尽可能少重复   |
|  `{n,}?`  |    重复 n 次以上，但尽可能少重复         |

```java
String reg="(\\d{1,2}?)(\\d{3,4})";        
String test="61762828 176 2991 87321";
System.out.println("文本："+test);
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
    System.out.println("匹配结果："+m1.group(0));
}
```

输出结果：

```cmd
文本：61762828 176 2991 87321
贪婪模式：(\d{1,2}?)(\d{3,4})
匹配结果：61762
匹配结果：2991
匹配结果：87321
```

> “61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762  
"2991"  是左边的懒惰匹配出2，右边的贪婪匹配出991  
"87321" 左边的懒惰匹配出8，右边的贪婪匹配出7321

#### 反义

前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：

|        元字符 |说明                           |
|:-------------:|:-----------------------------|
|   `\W`     |     匹配任意不是字母，数字，下划线，汉字的字符     |
|  `\S`   |    匹配任意不是空白符的字符   |
|   `\D`   |    匹配任意非数字的字符                       |
|   `\B`   |    匹配不是单词开头或结束的位置           |
|  `[^x]`    |    匹配除了 x 以外的任意字符                 |

就到这就到这，边学边用